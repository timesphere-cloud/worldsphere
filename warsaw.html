<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WorldSphere â€” aktualny czas i informacje sÅ‚oneczne</title>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Bubblegum+Sans&family=Outfit:wght@100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    :root{
      --bg:#0f1724; --card:rgba(255,255,255,0.04); --muted:#9aa4b2;
      --accent-start:#6ee7b7; --accent-end:#60a5fa; --glass:rgba(255,255,255,0.03);
      --height-nav:68px; font-family:'Outfit',system-ui,-apple-system,"Segoe UI",Roboto,Arial;
      color-scheme: dark;
    }
    html,body{height:100%;margin:0;background:
      radial-gradient(1200px 600px at 10% 10%, rgba(96,165,250,0.08), transparent 8%),
      radial-gradient(900px 500px at 90% 90%, rgba(110,231,183,0.04), transparent 8%),
      var(--bg); color:#e6eef8; -webkit-font-smoothing:antialiased; font-size:16px;}
    .nav{height:var(--height-nav);display:flex;align-items:center;padding:0 1rem;position:sticky;top:0;backdrop-filter:blur(6px);
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-bottom:1px solid rgba(255,255,255,0.03);z-index:80;}
    .nav-inner{max-width:1200px;margin:0 auto;width:100%;display:flex;align-items:center;justify-content:space-between;}
    .hamburger{width:46px;height:46px;display:grid;place-items:center;border-radius:10px;background:var(--glass);cursor:pointer;}
    .brand{display:flex;gap:0.6rem;align-items:center;font-weight:600;}
    .brand .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent-end),var(--accent-start));display:grid;place-items:center;font-weight:700;color:#05263b;}
    .search-btn{width:46px;height:46px;border-radius:10px;background:var(--glass);display:grid;place-items:center;cursor:pointer;}
    .search-input{position:absolute;right:0;top:50%;transform:translateY(-50%);width:0;opacity:0;pointer-events:none;transition:width .25s,opacity .18s;background:transparent;border:1px solid rgba(255,255,255,0.05);padding:10px 12px;border-radius:10px;color:inherit;}
    .search-input.visible{width:280px;opacity:1;pointer-events:auto;}

    .container{width:100%;padding:28px 28px 300px;box-sizing:border-box;}
    .card{max-width:1600px;margin:0 auto;width:100%;background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.01));border-radius:14px;padding:48px;display:grid;grid-template-columns:1fr auto;grid-template-rows:auto auto auto auto;gap:12px 20px;align-items:start;border:1px solid rgba(255,255,255,0.03);box-shadow:0 18px 60px rgba(2,8,23,0.55);}
    .time-block{grid-column:1 / -1;display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;}
    .city-title{font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:1px;}
    .time-now{font-weight:800;line-height:1;letter-spacing:0.6px;font-size: clamp(56px, 12vw, 180px);text-align:center;}
    .meta-zone{ text-align:center; color:var(--muted); font-weight:600; }

    .date{grid-column:2 / 3;justify-self:end;text-align:right;color:var(--muted);font-weight:600;}

    .dst-row{grid-column:1 / -1;display:flex;gap:14px;margin-top:10px;flex-wrap:wrap;}
    .dst-card{background:linear-gradient(180deg, rgba(255,255,255,0.018), rgba(255,255,255,0.01));border-radius:12px;padding:14px;min-width:220px;flex:1 1 260px;border:1px solid rgba(255,255,255,0.03);display:flex;gap:12px;align-items:center;}
    .dst-date{font-size:22px;font-weight:800;line-height:1;}
    .dst-info{color:var(--muted);font-size:13px;}

    .diff-section{grid-column:1 / -1;margin-top:22px;}
    .diff-title{font-weight:700;margin-bottom:10px;color:#d6e9fb;}
    .diff-wrap{background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.008));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);overflow:auto;}
    table.tdiff{border-collapse:collapse;width:100%;min-width:700px;}
    table.tdiff th, table.tdiff td{padding:8px 10px;text-align:center;border-bottom:1px solid rgba(255,255,255,0.03);font-size:13px;color:#e6eef8;}
    table.tdiff td.city{text-align:left;font-weight:600;color:#dfeaf6;}
    table.tdiff td.current{background:linear-gradient(90deg, rgba(96,165,250,0.06), rgba(110,231,183,0.04));}

    /* Solar info block */
    .solar-block{grid-column:1 / -1;margin-top:18px;display:flex;flex-wrap:wrap;gap:14px;align-items:flex-start;}
    .solar-card{background:linear-gradient(180deg, rgba(255,255,255,0.012), rgba(255,255,255,0.008));border-radius:12px;padding:14px;min-width:220px;flex:1 1 300px;border:1px solid rgba(255,255,255,0.03);}
    .solar-card h4{margin:0 0 8px 0;color:#d6e9fb;}
    .small-muted{color:var(--muted);font-size:13px;margin-top:6px;}
    footer{position:fixed;left:0;right:0;bottom:0;height:52px;display:flex;align-items:center;justify-content:center;background:linear-gradient(0deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-top:1px solid rgba(255,255,255,0.02);font-size:14px;color:var(--muted);z-index:70;}

    /* Side menu styles */
    .side-menu{
      position:fixed;
      top:0; left:-280px;
      width:280px; height:100%;
      background:#0b1220;
      border-right:1px solid rgba(255,255,255,.06);
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:12px;
      transition:left .28s cubic-bezier(.2,.9,.2,1);
      z-index:120;
    }
    .side-menu.open{ left:0; }
    .side-header{ font-size:18px; font-weight:700; margin-bottom:6px; color:#e6eef8; }
    .side-menu a{ padding:12px 14px; border-radius:10px; text-decoration:none; color:#e6eef8; background:rgba(255,255,255,.02); font-weight:600; display:flex; align-items:center; gap:8px; }
    .side-menu a:hover{ background:rgba(96,165,250,.12); }
    .menu-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.45); opacity:0; pointer-events:none; transition:opacity .2s; z-index:110; }
    .menu-backdrop.show{ opacity:1; pointer-events:auto; }

    @media (max-width:900px){ .card{padding:28px;grid-template-columns:1fr;grid-template-rows:auto auto auto auto;} .date{grid-column:1 / -1;justify-self:end;} table.tdiff{min-width:520px;} }
    @media (max-width:460px){ .time-now{font-size: clamp(36px, 18vw, 72px);} .card{padding:20px;border-radius:12px;} }
  </style>
</head>
<body>
  <header class="nav" role="banner">
    <div class="nav-inner">
      <div style="display:flex;align-items:center;gap:.8rem">
        <div class="hamburger" id="hamburger" title="Menu"><span class="material-icons">menu</span></div>
        <div class="brand" aria-hidden="true"><div class="logo">WS</div>
          <div style="font-size:15px">WorldSphere</div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:.6rem;position:relative">
        <input id="searchInput" class="search-input" placeholder="Wpisz miasto i naciÅ›nij Enter..." aria-label="Wyszukaj miasto" autocomplete="off" />
        <div id="searchBtn" class="search-btn" title="Szukaj"><span class="material-icons">search</span></div>
      </div>
    </div>
  </header>

  <!-- SIDE MENU -->
  <div id="sideMenu" class="side-menu" aria-hidden="true">
    <div class="side-header">WorldSphere</div>
    <a href="/worldsphere/unix.html" id="linkUnix">ðŸ•’ Unix Time</a>
    <a href="/worldsphere/calendar.html" id="linkCalendar">ðŸ“… Calendar</a>
    <a href="/worldsphere/system.html" id="linkSystem">ðŸ’» System Time</a>
    <div style="margin-top:auto; font-size:13px; color:var(--muted)">Â© 2026 WorldSphere</div>
  </div>
  <div id="menuBackdrop" class="menu-backdrop" aria-hidden="true"></div>

  <main class="container" role="main">
    <section class="card" aria-labelledby="cityHeading">
      <div class="time-block">
        <div class="city-title" id="cityHeading">aktualny czas w: â€”</div>
        <div class="time-now" id="timeNow">--:--:--</div>
        <div class="meta-zone" id="tzMeta">strefa: â€” Â· UTCâ€”</div>
      </div>

      <div class="date" id="dateNow">â€”</div>

      <div class="dst-row" id="dstRow"></div>

      <div class="diff-section" id="diffSection">
        <div class="diff-title">RÃ³Å¼nice czasowe miÄ™dzy najwiÄ™kszymi miastami (w godzinach)</div>
        <div class="diff-wrap" id="diffWrap">
          <div class="small-muted">Tabela pokazuje rÃ³Å¼nicÄ™ (kolumna minus wiersz) zaokrÄ…glonÄ… do 0.5h (np. +2h, -5.5h).</div>
        </div>
      </div>

      <!-- SOLAR INFO -->
      <div class="solar-block" id="solarBlock">
        <div class="solar-card" id="coordsCard">
          <h4>WspÃ³Å‚rzÄ™dne geograficzne</h4>
          <div id="coordsText">â€”</div>
        </div>

        <div class="solar-card" id="solarDiffCard">
          <h4>RÃ³Å¼nica: czas sÅ‚oneczny vs czas lokalny (dzisiaj)</h4>
          <div id="solarDiffText">â€”</div>
        </div>

        <div class="solar-card" id="sunCard">
          <h4>WschÃ³d, zachÃ³d i dÅ‚ugoÅ›Ä‡ dnia (dzisiaj)</h4>
          <div id="sunText">â€”</div>
        </div>
      </div>

    </section>
  </main>

  <footer>Â© 2026 WorldSphere</footer>

  <script>
    /* ---------- Utilities ---------- */
    function getFilenameRaw() {
      const path = window.location.pathname || '';
      let last = path.split('/').filter(Boolean).pop() || '';
      last = last.split('?')[0].split('#')[0];
      last = last.replace(/\.[a-zA-Z0-9]+$/, '');
      return last;
    }
    function prettyNameFromRaw(raw) {
      if (!raw) return null;
      const decoded = decodeURIComponent(raw.replace(/[-_]+/g, ' '));
      return decoded.split(' ').map(w => w ? (w[0].toUpperCase() + w.slice(1)) : '').join(' ').trim();
    }

    let allIana = [];
    if (typeof Intl.supportedValuesOf === 'function') {
      try { allIana = Intl.supportedValuesOf('timeZone'); } catch(e){ allIana = []; }
    }

    const cityDb = {
      'warszawa': { tz:'Europe/Warsaw', lat:52.2297, lon:21.0122 },
      'warsaw': { tz:'Europe/Warsaw', lat:52.2297, lon:21.0122 },
      'london': { tz:'Europe/London', lat:51.5072, lon:-0.1276 },
      'paris': { tz:'Europe/Paris', lat:48.8566, lon:2.3522 },
      'new york': { tz:'America/New_York', lat:40.7128, lon:-74.0060 },
      'newyork': { tz:'America/New_York', lat:40.7128, lon:-74.0060 },
      'los angeles': { tz:'America/Los_Angeles', lat:34.0522, lon:-118.2437 },
      'losangeles': { tz:'America/Los_Angeles', lat:34.0522, lon:-118.2437 },
      'tokyo': { tz:'Asia/Tokyo', lat:35.6895, lon:139.6917 },
      'sydney': { tz:'Australia/Sydney', lat:-33.8688, lon:151.2093 },
      'beijing': { tz:'Asia/Shanghai', lat:39.9042, lon:116.4074 },
      'mumbai': { tz:'Asia/Kolkata', lat:19.0760, lon:72.8777 },
      'moscow': { tz:'Europe/Moscow', lat:55.7558, lon:37.6173 },
      'dubai': { tz:'Asia/Dubai', lat:25.2048, lon:55.2708 },
      'sao paulo': { tz:'America/Sao_Paulo', lat:-23.5505, lon:-46.6333 }
    };

    function detectTZFromRaw(raw) {
      if (!raw) return null;
      const mayBeSlash = raw.replace(/_/g, '/').replace(/-/g, '/');
      if (allIana.length) {
        const found = allIana.find(z => z.toLowerCase() === mayBeSlash.toLowerCase());
        if (found) return found;
      }
      const key = raw.toLowerCase();
      if (cityDb[key]) return cityDb[key].tz;
      if (allIana.length) {
        const simple = raw.toLowerCase();
        const candidate = allIana.find(z => z.toLowerCase().endsWith('/' + simple) || z.toLowerCase().endsWith('/' + simple.replace(/ /g,'_')));
        if (candidate) return candidate;
      }
      return null;
    }

    const raw = getFilenameRaw();
    const displayCity = prettyNameFromRaw(raw) || 'Twoje miasto';
    const tzDetected = detectTZFromRaw(raw);
    const tz = tzDetected || null;

    const coordsKnown = (() => {
      const key = raw.toLowerCase();
      if (cityDb[key]) return {lat: cityDb[key].lat, lon: cityDb[key].lon};
      if (tz) {
        const parts = tz.split('/');
        const maybeCity = parts[parts.length-1].replace(/_/g,' ').toLowerCase();
        if (cityDb[maybeCity]) return {lat: cityDb[maybeCity].lat, lon: cityDb[maybeCity].lon};
      }
      return null;
    })();

    // DOM refs
    const cityHeading = document.getElementById('cityHeading');
    const timeNowEl = document.getElementById('timeNow');
    const dateNowEl = document.getElementById('dateNow');
    const tzMeta = document.getElementById('tzMeta');
    const dstRow = document.getElementById('dstRow');
    const diffWrap = document.getElementById('diffWrap');
    const coordsText = document.getElementById('coordsText');
    const solarDiffText = document.getElementById('solarDiffText');
    const sunText = document.getElementById('sunText');

    cityHeading.textContent = 'aktualny czas w: ' + displayCity;

    /* ---------- time helpers ---------- */
    function getOffsetMinutesForDate(date, timeZone) {
      try {
        const fmt = new Intl.DateTimeFormat('en-US', {
          timeZone,
          year: 'numeric', month: '2-digit', day: '2-digit',
          hour: '2-digit', minute: '2-digit', second: '2-digit',
          hour12: false
        });
        const parts = fmt.formatToParts(date);
        const obj = {};
        parts.forEach(p => { if (p.type !== 'literal') obj[p.type] = p.value; });
        const y = parseInt(obj.year,10), m = parseInt(obj.month,10), d = parseInt(obj.day,10);
        const hh = parseInt(obj.hour,10), mm = parseInt(obj.minute,10), ss = parseInt(obj.second,10);
        const tzMs = Date.UTC(y, m-1, d, hh, mm, ss);
        return Math.round((tzMs - date.getTime()) / 60000);
      } catch (e) { return null; }
    }
    function formatUtcOffset(mins) {
      if (mins === null || typeof mins === 'undefined') return 'UTC?';
      const sign = mins >= 0 ? '+' : '-';
      const a = Math.abs(mins);
      const h = Math.floor(a / 60);
      const m = a % 60;
      return 'UTC' + sign + h + (m ? (':' + String(m).padStart(2,'0')) : '');
    }
    function fmtLocal(dateObj, tzName) {
      try { return new Intl.DateTimeFormat('pl-PL', { hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, timeZone: tzName }).format(dateObj); }
      catch (e) { return dateObj.toTimeString().split(' ')[0]; }
    }
    function fmtLocalDateTime(dateObj, tzName) {
      try { return new Intl.DateTimeFormat('pl-PL', { weekday:'long', year:'numeric', month:'long', day:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:false, timeZone: tzName }).format(dateObj); }
      catch (e) { return dateObj.toString(); }
    }

    /* ---------- clock ---------- */
    function updateClockAndMeta() {
      const now = new Date();
      const timeOpts = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false };
      const dateOpts = { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' };
      try {
        if (tz) {
          timeNowEl.textContent = new Intl.DateTimeFormat('pl-PL', { ...timeOpts, timeZone: tz }).format(now);
          dateNowEl.textContent = new Intl.DateTimeFormat('pl-PL', { ...dateOpts, timeZone: tz }).format(now);
          const off = getOffsetMinutesForDate(now, tz);
          tzMeta.textContent = tz + ' Â· ' + formatUtcOffset(off);
        } else {
          timeNowEl.textContent = new Intl.DateTimeFormat('pl-PL', timeOpts).format(now);
          dateNowEl.textContent = new Intl.DateTimeFormat('pl-PL', dateOpts).format(now);
          const localOff = -now.getTimezoneOffset();
          tzMeta.textContent = 'lokalna strefa przeglÄ…darki' + ' Â· ' + formatUtcOffset(localOff);
        }
      } catch (err) {
        timeNowEl.textContent = now.toTimeString().split(' ')[0];
        dateNowEl.textContent = now.toDateString();
      }
    }
    updateClockAndMeta();
    setInterval(updateClockAndMeta, 1000);

    /* ---------- DST detection (simplified) ---------- */
    function refineTransition(beforeDate, afterDate, timeZone) {
      let beforeOff = getOffsetMinutesForDate(beforeDate, timeZone);
      let afterOff = getOffsetMinutesForDate(afterDate, timeZone);
      if (beforeOff === null || afterOff === null || beforeOff === afterOff) return null;
      let lo = beforeDate.getTime(), hi = afterDate.getTime();
      while (hi - lo > 60000) {
        const mid = Math.floor((lo + hi) / 2);
        const midOff = getOffsetMinutesForDate(new Date(mid), timeZone);
        if (midOff === beforeOff) lo = mid; else hi = mid;
      }
      return { when: new Date(hi), beforeOffset: beforeOff, afterOffset: afterOff };
    }
    function detectTransitions(timeZone) {
      if (!timeZone) return [];
      const now = new Date();
      const ONE_DAY = 24*60*60*1000;
      const range = 400;
      let transitions = [];
      let prevDate = new Date(now.getTime() - range*ONE_DAY);
      let prevOff = getOffsetMinutesForDate(prevDate, timeZone);
      for (let i=1;i<=range*2;i++){
        const d = new Date(prevDate.getTime() + ONE_DAY*i);
        const off = getOffsetMinutesForDate(d, timeZone);
        if (off === null || prevOff === null) { prevOff = off; continue; }
        if (off !== prevOff) {
          const approxBefore = new Date(d.getTime() - ONE_DAY);
          const precise = refineTransition(approxBefore, d, timeZone);
          if (precise) transitions.push(precise);
        }
        prevOff = off;
      }
      transitions.sort((a,b)=> a.when - b.when);
      return transitions;
    }
    function buildDstCard(trans) {
      const card = document.createElement('div'); card.className = 'dst-card';
      const dateDiv = document.createElement('div'); dateDiv.className='dst-date';
      const infoDiv = document.createElement('div'); infoDiv.className='dst-info';
      if (!trans) {
        dateDiv.textContent='â€”';
        infoDiv.innerHTML='<div>Brak dostÄ™pnej daty w zakresie Â±1 roku</div>';
      } else {
        const when = trans.when;
        dateDiv.textContent = new Intl.DateTimeFormat('pl-PL', { day:'2-digit', month:'short', year:'numeric', timeZone: tz || undefined }).format(when);
        const before = trans.beforeOffset, after = trans.afterOffset, delta = after - before;
        const started = delta > 0;
        const which = started ? 'Czas letni (DST) rozpoczÄ…Å‚ siÄ™' : 'Czas letni (DST) zakoÅ„czyÅ‚ siÄ™';
        const localTimeStr = fmtLocalDateTime(when, tz || undefined);
        const offsetStr = formatUtcOffset(after);
        infoDiv.innerHTML = `<div style="font-weight:700;margin-bottom:6px">${which}</div>
          <div>${localTimeStr} (lokalny czas)</div>
          <div>Nowy offset: ${offsetStr} (zmiana ${delta/60} h)</div>`;
      }
      card.appendChild(dateDiv); card.appendChild(infoDiv);
      return card;
    }
    function renderDstInfo() {
      dstRow.innerHTML = '';
      if (!tz) {
        const n = document.createElement('div'); n.className='dst-card'; n.style.flex='1 1 100%';
        n.innerHTML = '<div class="dst-date">â€”</div><div class="dst-info">Brak IANA timezone powiÄ…zanej z tÄ… nazwÄ… pliku. UÅ¼yj nazwy pliku w formacie IANA (np. Europe_Warsaw) lub znanej nazwy miasta.</div>';
        dstRow.appendChild(n); return;
      }
      const transitions = detectTransitions(tz);
      const now = new Date(); let last=null,next=null;
      for (const t of transitions) {
        if (t.when.getTime() < now.getTime()) last = t;
        if (t.when.getTime() > now.getTime() && !next) next = t;
      }
      dstRow.appendChild(buildDstCard(last)); dstRow.appendChild(buildDstCard(next));
    }
    try { renderDstInfo(); } catch(e){ console.warn('DST error', e); }

    /* ---------- time differences matrix ---------- */
    const majorCities = [
      { label:'New York', tz:'America/New_York' },
      { label:'Los Angeles', tz:'America/Los_Angeles' },
      { label:'London', tz:'Europe/London' },
      { label:'Paris', tz:'Europe/Paris' },
      { label:'Moscow', tz:'Europe/Moscow' },
      { label:'Dubai', tz:'Asia/Dubai' },
      { label:'Mumbai', tz:'Asia/Kolkata' },
      { label:'Beijing', tz:'Asia/Shanghai' },
      { label:'Tokyo', tz:'Asia/Tokyo' },
      { label:'Sydney', tz:'Australia/Sydney' },
      { label:'SÃ£o Paulo', tz:'America/Sao_Paulo' }
    ];
    function formatDiffHours(minsDiff) {
      if (minsDiff === null) return 'â€”';
      const hours = minsDiff/60;
      const rounded = Math.round(hours*2)/2;
      return (rounded >= 0 ? '+' : '') + (rounded) + 'h';
    }
    function buildTimeDiffTable() {
      const wrap = document.getElementById('diffWrap');
      const existing = wrap.querySelector('table.tdiff'); if (existing) existing.remove();
      const now = new Date();
      const offsets = majorCities.map(c => getOffsetMinutesForDate(now, c.tz));
      const table = document.createElement('table'); table.className='tdiff';

      // HEAD
      const thead = document.createElement('thead');
      const hr = document.createElement('tr');
      const thCorner = document.createElement('th'); thCorner.textContent = ''; hr.appendChild(thCorner);
      majorCities.forEach((c, idx) => {
        const th = document.createElement('th');
        th.textContent = c.label + (offsets[idx] !== null ? ('\n' + formatUtcOffset(offsets[idx])) : '');
        hr.appendChild(th);
      });
      thead.appendChild(hr);
      table.appendChild(thead);

      // BODY
      const tbody = document.createElement('tbody');
      majorCities.forEach((rowCity, i) => {
        const tr = document.createElement('tr');
        const tdCity = document.createElement('td'); tdCity.className='city'; tdCity.textContent = rowCity.label;
        tr.appendChild(tdCity);
        majorCities.forEach((colCity, j) => {
          const td = document.createElement('td');
          const offRow = offsets[i], offCol = offsets[j];
          if (offRow === null || offCol === null) td.textContent = 'â€”';
          else td.textContent = formatDiffHours(offCol - offRow);
          if (tz && (rowCity.tz === tz || colCity.tz === tz)) td.classList.add('current');
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
      wrap.insertBefore(table, wrap.firstChild);
    }
    buildTimeDiffTable();
    setInterval(buildTimeDiffTable, 60*1000);

    /* ---------- Solar calculations (NOAA-like) ---------- */
    const RAD = Math.PI/180, DEG = 180/Math.PI;
    function toJulian(date) { return date.getTime()/86400000 + 2440587.5; }
    function julianCenturies(jd) { return (jd - 2451545.0) / 36525.0; }
    function limitDeg(d) { return (d % 360 + 360) % 360; }

    function solarCoordsAndEqTime(jd) {
      const T = julianCenturies(jd);
      const L0 = limitDeg(280.46646 + T*(36000.76983 + T*0.0003032));
      const M = limitDeg(357.52911 + T*(35999.05029 - 0.0001537*T));
      const e = 0.016708634 - T*(0.000042037 + 0.0000001267*T);
      const Mrad = M * RAD;
      const C = Math.sin(Mrad)*(1.914602 - T*(0.004817 + 0.000014*T)) + Math.sin(2*Mrad)*(0.019993 - 0.000101*T) + Math.sin(3*Mrad)*0.000289;
      const sunTrueLong = L0 + C;
      const omega = 125.04 - 1934.136 * T;
      const sunAppLong = sunTrueLong - 0.00569 - 0.00478 * Math.sin(omega * RAD);
      const meanObliq = 23 + (26 + ((21.448 - T*(46.815 + T*(0.00059 - T*0.001813))) / 60)) / 60;
      const obliqCorr = meanObliq + 0.00256 * Math.cos(omega * RAD);
      const decl = Math.asin(Math.sin(obliqCorr * RAD) * Math.sin(sunAppLong * RAD));
      const y = Math.tan((obliqCorr/2) * RAD);
      const y2 = y*y;
      const L0rad = L0 * RAD;
      const eqTime = 4 * DEG * ( y2 * Math.sin(2*L0rad) - 2*e*Math.sin(Mrad) + 4*e*y2*Math.sin(Mrad)*Math.cos(2*L0rad) - 0.5*y2*y2*Math.sin(4*L0rad) - 1.25*e*e*Math.sin(2*Mrad) );
      return { eqTimeMinutes: eqTime, declinationRad: decl };
    }

    function computeSunriseSunset(lat, lon, dateUTC0) {
      const jd = toJulian(dateUTC0);
      const { eqTimeMinutes, declinationRad } = solarCoordsAndEqTime(jd);
      const solarNoonUTCmin = 720 - 4 * lon - eqTimeMinutes;
      const latRad = lat * RAD;
      const sunDecl = declinationRad;
      const zenithDeg = 90.833;
      const cosH = (Math.cos(zenithDeg * RAD) - Math.sin(latRad) * Math.sin(sunDecl)) / (Math.cos(latRad) * Math.cos(sunDecl));
      if (cosH < -1 || cosH > 1) return { sunrise:null, sunset:null, solarNoonUTCmin, dayLengthMin: null };
      const Hdeg = Math.acos(cosH) * DEG;
      const sunriseUTCmin = solarNoonUTCmin - 4 * Hdeg;
      const sunsetUTCmin  = solarNoonUTCmin + 4 * Hdeg;
      const dayLengthMin = (sunsetUTCmin - sunriseUTCmin);
      function minutesToUTCDate(mins) {
        const ms = Math.round(mins * 60000);
        return new Date(Date.UTC(dateUTC0.getUTCFullYear(), dateUTC0.getUTCMonth(), dateUTC0.getUTCDate(),0,0,0) + ms);
      }
      return {
        sunriseUTC: minutesToUTCDate(sunriseUTCmin),
        sunsetUTC: minutesToUTCDate(sunsetUTCmin),
        solarNoonUTC: minutesToUTCDate(solarNoonUTCmin),
        dayLengthMin: Math.round(dayLengthMin)
      };
    }

    function equationOfTimeMinutesForDate(dateUTC) {
      const jd = toJulian(new Date(Date.UTC(dateUTC.getUTCFullYear(), dateUTC.getUTCMonth(), dateUTC.getUTCDate(),0,0,0)));
      return solarCoordsAndEqTime(jd).eqTimeMinutes;
    }

    function renderSolarAndCoords() {
      if (!coordsKnown) {
        coordsText.innerHTML = '<div>Brak wspÃ³Å‚rzÄ™dnych dla tej nazwy pliku. Dodaj do bazy lub nazwij plik np. "Europe_Warsaw.html".</div>';
        solarDiffText.textContent = 'â€”';
        sunText.textContent = 'â€”';
        return;
      }
      const lat = coordsKnown.lat, lon = coordsKnown.lon;
      coordsText.innerHTML = `<div>Latitude: ${lat}Â°, Longitude: ${lon}Â°</div>`;

      // determine local calendar date for the place
      const now = new Date();
      let localYear, localMonth, localDay;
      try {
        const parts = new Intl.DateTimeFormat('en-CA', { timeZone: tz || undefined, year:'numeric', month:'2-digit', day:'2-digit' }).formatToParts(now);
        const obj = {}; for (const p of parts) if (p.type!=='literal') obj[p.type]=p.value;
        localYear = parseInt(obj.year,10); localMonth = parseInt(obj.month,10)-1; localDay = parseInt(obj.day,10);
      } catch(e) {
        localYear = now.getUTCFullYear(); localMonth = now.getUTCMonth(); localDay = now.getUTCDate();
      }
      const dateLocalMidnightUTC = new Date(Date.UTC(localYear, localMonth, localDay, 0,0,0));
      const eqMinutes = equationOfTimeMinutesForDate(dateLocalMidnightUTC);

      const offsetNow = tz ? getOffsetMinutesForDate(new Date(), tz) : -new Date().getTimezoneOffset();
      const diffSolarMinusLocal = Math.round(4*lon + eqMinutes - offsetNow);
      const sign = diffSolarMinusLocal >= 0 ? '+' : '-';
      solarDiffText.innerHTML = `<div>RÃ³Å¼nica (czas sÅ‚oneczny âˆ’ czas lokalny): <strong>${sign}${Math.abs(diffSolarMinusLocal)} min</strong></div>
        <div class="small-muted">EoT = ${eqMinutes.toFixed(2)} min dla daty: ${new Intl.DateTimeFormat('pl-PL', { year:'numeric', month:'long', day:'numeric', timeZone: tz||undefined }).format(dateLocalMidnightUTC)}</div>`;

      const sunInfo = computeSunriseSunset(lat, lon, dateLocalMidnightUTC);
      if (!sunInfo.sunriseUTC || !sunInfo.sunsetUTC) {
        sunText.innerHTML = `<div>Na tej szerokoÅ›ci i dacie SÅ‚oÅ„ce nie wschodzi/nie zachodzi (dzieÅ„ polarny / noc polarna).</div>`;
      } else {
        const sunriseLocalStr = fmtLocal(sunInfo.sunriseUTC, tz || undefined);
        const sunsetLocalStr = fmtLocal(sunInfo.sunsetUTC, tz || undefined);
        const solarNoonLocalStr = fmtLocal(sunInfo.solarNoonUTC, tz || undefined);
        const dayLenMin = sunInfo.dayLengthMin;
        const hours = Math.floor(dayLenMin / 60), mins = dayLenMin % 60;
        sunText.innerHTML = `<div><strong>WschÃ³d:</strong> ${sunriseLocalStr}</div>
                             <div><strong>ZachÃ³d:</strong> ${sunsetLocalStr}</div>
                             <div><strong>DÅ‚ugoÅ›Ä‡ dnia:</strong> ${hours}h ${mins}m</div>
                             <div class="small-muted">Solar noon: ${solarNoonLocalStr} (lokalny czas)</div>`;
      }
    }
    renderSolarAndCoords();

    /* ---------- UI: side menu & search ---------- */
    const sideMenu = document.getElementById('sideMenu');
    const backdrop = document.getElementById('menuBackdrop');
    const hamburgerBtn = document.getElementById('hamburger');

    function openSideMenu() {
      sideMenu.classList.add('open');
      backdrop.classList.add('show');
      sideMenu.setAttribute('aria-hidden', 'false');
      backdrop.setAttribute('aria-hidden', 'false');
    }
    function closeSideMenu() {
      sideMenu.classList.remove('open');
      backdrop.classList.remove('show');
      sideMenu.setAttribute('aria-hidden', 'true');
      backdrop.setAttribute('aria-hidden', 'true');
    }

    hamburgerBtn.addEventListener('click', openSideMenu);
    backdrop.addEventListener('click', closeSideMenu);

    // keyboard: Esc closes menu
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') closeSideMenu();
    });

    // search behaviour (same as before)
    const searchBtn = document.getElementById('searchBtn');
    const searchInput = document.getElementById('searchInput');
    let searchVisible=false;
    function openSearch(){ searchVisible=true; searchInput.classList.add('visible'); searchInput.focus(); searchInput.select(); }
    function closeSearch(){ searchVisible=false; searchInput.classList.remove('visible'); searchInput.blur(); }
    function doSearch(){ const val = (searchInput.value||'').trim(); const encoded = encodeURIComponent(val); window.location.href = '/worldsphere/search_cities?value=' + encoded; }
    searchBtn.addEventListener('click', ()=>{ if(!searchVisible) openSearch(); else doSearch(); });
    searchInput.addEventListener('keydown',(e)=>{ if(e.key==='Enter'){ e.preventDefault(); doSearch(); } else if(e.key==='Escape'){ closeSearch(); }});
    document.addEventListener('keydown',(e)=>{ if(e.key==='/' && !e.metaKey && !e.ctrlKey && !e.altKey){ e.preventDefault(); openSearch(); }});

    // accessibility: close menu on focusout if clicked outside
    document.addEventListener('click', (e) => {
      if (!sideMenu.classList.contains('open')) return;
      if (!sideMenu.contains(e.target) && !hamburgerBtn.contains(e.target)) {
        closeSideMenu();
      }
    });

    // Highlight current menu item if current path matches (optional)
    (function highlightMenu() {
      try {
        const path = window.location.pathname || '';
        if (path.includes('/worldsphere/unix')) document.getElementById('linkUnix').style.background = 'rgba(96,165,250,0.12)';
        if (path.includes('/worldsphere/calendar')) document.getElementById('linkCalendar').style.background = 'rgba(96,165,250,0.12)';
        if (path.includes('/worldsphere/system')) document.getElementById('linkSystem').style.background = 'rgba(96,165,250,0.12)';
      } catch(e){}
    })();

    // expose debug info if needed
    // window._ws_debug = { tz, coordsKnown };
  </script>
</body>
</html>
